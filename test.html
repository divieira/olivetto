<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Olivetto</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@700&display=swap" rel="stylesheet">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  html, body {
    height: 100%;
    overflow: hidden;
    font-family: 'Nunito', sans-serif;
    background: #fff;
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
    -webkit-user-select: none;
  }

  #app {
    display: flex;
    flex-direction: column;
    height: 100dvh;
    height: 100vh;
  }

  /* ── Color bar ── */
  #color-bar {
    display: flex;
    justify-content: center;
    gap: 12px;
    padding: 14px 10px 8px;
    flex-shrink: 0;
  }

  .color-dot {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    border: 3px solid transparent;
    cursor: pointer;
    transition: transform 0.15s, border-color 0.15s;
  }

  .color-dot:hover { transform: scale(1.15); }
  .color-dot.selected { border-color: #ccc; transform: scale(1.2); }

  /* ── Main writing area ── */
  #writing-area {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
    cursor: text;
    position: relative;
    overflow-y: auto;
  }

  #text-display {
    font-size: min(14vw, 80px);
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    text-align: center;
    word-break: break-word;
    white-space: pre-wrap;
    line-height: 1.3;
    color: #000;
    width: 100%;
  }

  #text-display .letter {
    display: inline-block;
    transition: opacity 0.1s;
  }

  #text-display .letter.blink {
    animation: letterBlink 0.35s ease-in-out;
  }

  @keyframes letterBlink {
    0%   { opacity: 1; transform: scale(1); }
    30%  { opacity: 0.2; transform: scale(1.15); }
    60%  { opacity: 1; transform: scale(1.05); }
    100% { opacity: 1; transform: scale(1); }
  }

  /* Blinking cursor */
  #cursor {
    display: inline-block;
    width: 3px;
    height: 0.9em;
    background: currentColor;
    margin-left: 2px;
    vertical-align: baseline;
    animation: cursorBlink 1s step-end infinite;
  }

  @keyframes cursorBlink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0; }
  }

  /* ── Hidden input for keyboard (dead keys + mobile) ── */
  #hidden-input {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
    font-size: 16px;
    caret-color: transparent;
    z-index: 10;
  }

  /* ── Navigation ── */
  #nav-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 20px 16px;
    flex-shrink: 0;
  }

  .nav-btn {
    font-size: 32px;
    background: none;
    border: none;
    cursor: pointer;
    color: #bbb;
    padding: 8px 16px;
    border-radius: 12px;
    transition: color 0.15s, background 0.15s;
    font-family: 'Nunito', sans-serif;
    line-height: 1;
  }

  .nav-btn:hover { color: #888; background: #f0f0f0; }
  .nav-btn:disabled { opacity: 0.25; cursor: default; }
  .nav-btn:disabled:hover { background: none; color: #bbb; }

  #page-indicator {
    font-size: 14px;
    color: #ccc;
    font-weight: 700;
  }

  #btn-new-page {
    font-size: 22px;
    background: none;
    border: 2px solid #ddd;
    cursor: pointer;
    color: #bbb;
    padding: 4px 12px;
    border-radius: 10px;
    transition: color 0.15s, background 0.15s, border-color 0.15s;
    font-family: 'Nunito', sans-serif;
    line-height: 1;
  }
  #btn-new-page:hover { color: #888; background: #f0f0f0; border-color: #bbb; }
</style>
</head>
<body>

<div id="app">
  <div id="color-bar"></div>

  <div id="writing-area">
    <div id="text-display"><span id="cursor"></span></div>
    <input id="hidden-input" type="text" autocapitalize="characters" autocomplete="off" autocorrect="off" spellcheck="false">
  </div>

  <div id="nav-bar">
    <button class="nav-btn" id="btn-prev" aria-label="Previous page">&#9664;</button>
    <span id="page-indicator"></span>
    <button id="btn-new-page" aria-label="New page">+</button>
    <button class="nav-btn" id="btn-next" aria-label="Next page">&#9654;</button>
  </div>
</div>

<script>
(function () {
  // ── Config ──
  const COLORS = [
    { name: 'red',    hex: '#E53935' },
    { name: 'green',  hex: '#43A047' },
    { name: 'blue',   hex: '#1E88E5' },
    { name: 'yellow', hex: '#FDD835' },
    { name: 'orange', hex: '#FB8C00' },
    { name: 'pink',   hex: '#EC407A' },
    { name: 'purple', hex: '#8E24AA' },
    { name: 'black',  hex: '#222222' },
  ];

  const STORAGE_KEY = 'olivetto';

  // ── State ──
  let pages, currentPage, currentColor;

  function loadState() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (raw) {
        const s = JSON.parse(raw);
        pages = s.pages && s.pages.length ? s.pages : [''];
        currentPage = typeof s.currentPage === 'number' ? Math.min(s.currentPage, pages.length - 1) : 0;
        currentColor = s.color || COLORS[7].hex;
      } else {
        pages = [''];
        currentPage = 0;
        currentColor = COLORS[7].hex;
      }
    } catch {
      pages = [''];
      currentPage = 0;
      currentColor = COLORS[7].hex;
    }
  }

  function saveState() {
    localStorage.setItem(STORAGE_KEY, JSON.stringify({
      pages: pages,
      currentPage: currentPage,
      color: currentColor,
    }));
  }

  // ── DOM refs ──
  const textDisplay = document.getElementById('text-display');
  const cursor = document.getElementById('cursor');
  const hiddenInput = document.getElementById('hidden-input');
  const colorBar = document.getElementById('color-bar');
  const btnPrev = document.getElementById('btn-prev');
  const btnNext = document.getElementById('btn-next');
  const btnNewPage = document.getElementById('btn-new-page');
  const pageIndicator = document.getElementById('page-indicator');
  const writingArea = document.getElementById('writing-area');

  // ── Render ──
  function render() {
    const text = pages[currentPage] || '';

    // Build letter spans, preserving newlines
    let html = '';
    for (let i = 0; i < text.length; i++) {
      const ch = text[i];
      if (ch === '\n') {
        html += '<br>';
      } else if (ch === ' ') {
        html += ' ';
      } else {
        html += '<span class="letter">' + ch + '</span>';
      }
    }

    textDisplay.innerHTML = html;
    textDisplay.appendChild(cursor);
    textDisplay.style.color = currentColor;

    // Nav
    btnPrev.disabled = currentPage === 0;
    btnNext.disabled = currentPage >= pages.length - 1;
    pageIndicator.textContent = (currentPage + 1) + ' / ' + pages.length;

    // Scroll to bottom of writing area
    writingArea.scrollTop = writingArea.scrollHeight;
  }

  // ── Color bar ──
  function buildColorBar() {
    COLORS.forEach(function (c) {
      const dot = document.createElement('div');
      dot.className = 'color-dot';
      dot.style.background = c.hex;
      if (c.hex === currentColor) dot.classList.add('selected');
      dot.addEventListener('click', function (e) {
        e.stopPropagation();
        currentColor = c.hex;
        document.querySelectorAll('.color-dot').forEach(function (d) { d.classList.remove('selected'); });
        dot.classList.add('selected');
        saveState();
        render();
        focusInput();
      });
      colorBar.appendChild(dot);
    });
  }

  // ── Speech ──
  // Native Web Speech API with automatic fallback to Google Translate TTS
  // for browsers where speechSynthesis exists but silently fails (e.g. Chrome Android).
  let ptVoice = null;
  let useFallbackTTS = false;
  let nativeTTSConfirmed = false;
  let firstSpeakTime = 0;
  let fallbackAudio = null;
  let fallbackTimer = null;

  function pickVoice() {
    var voices = (window.speechSynthesis && window.speechSynthesis.getVoices()) || [];
    // Prefer "Google português do Brasil" specifically
    for (var i = 0; i < voices.length; i++) {
      if (voices[i].name === 'Google português do Brasil') {
        ptVoice = voices[i];
        return;
      }
    }
    // Fallback: any pt-BR voice
    var candidates = [];
    for (var i = 0; i < voices.length; i++) {
      var lang = (voices[i].lang || '').replace('_', '-');
      if (lang.indexOf('pt-BR') === 0 || lang === 'pt-BR') {
        candidates.push(voices[i]);
      }
    }
    // If no pt-BR, try any pt voice
    if (candidates.length === 0) {
      for (var i = 0; i < voices.length; i++) {
        var lang = (voices[i].lang || '').replace('_', '-');
        if (lang.indexOf('pt') === 0) {
          candidates.push(voices[i]);
        }
      }
    }
    if (candidates.length > 0) ptVoice = candidates[0];
  }

  if (window.speechSynthesis) {
    pickVoice();
    window.speechSynthesis.addEventListener('voiceschanged', pickVoice);
    // If no voices load within 3 seconds, preemptively enable fallback
    setTimeout(function () {
      if (!nativeTTSConfirmed && !useFallbackTTS) {
        var voices = window.speechSynthesis.getVoices();
        if (!voices || voices.length === 0) {
          useFallbackTTS = true;
        }
      }
    }, 3000);
  } else {
    // No speechSynthesis at all — go straight to fallback
    useFallbackTTS = true;
  }

  function speak(text) {
    if (!text) return;

    if (useFallbackTTS) {
      speakFallback(text);
      return;
    }

    window.speechSynthesis.cancel();
    pickVoice();

    // Send as lowercase so TTS reads phonetically (e.g. "to" not "Tocantins")
    var u = new SpeechSynthesisUtterance(text.toLowerCase());
    u.lang = 'pt-BR';
    if (ptVoice) u.voice = ptVoice;
    u.rate = 0.65;
    u.pitch = 1.1;

    // Detect whether native TTS is actually producing audio.
    // On some browsers (notably Chrome Android), speechSynthesis exists
    // but speak() silently does nothing. We track onstart across calls
    // and switch to the audio fallback if it never fires.
    if (!nativeTTSConfirmed) {
      if (!firstSpeakTime) firstSpeakTime = Date.now();

      u.onstart = function () { nativeTTSConfirmed = true; };
      u.onerror = function () {
        if (!nativeTTSConfirmed) {
          useFallbackTTS = true;
          speakFallback(text);
        }
      };

      // After 2 seconds of attempts with no onstart, switch to fallback
      if (Date.now() - firstSpeakTime > 2000) {
        useFallbackTTS = true;
        speakFallback(text);
        return;
      }
    }

    window.speechSynthesis.speak(u);
  }

  function speakFallback(text) {
    if (!text) return;
    // Debounce rapid keystrokes to avoid excessive network requests.
    // After 250 ms of silence the most recent text is spoken via audio.
    if (fallbackTimer) clearTimeout(fallbackTimer);
    fallbackTimer = setTimeout(function () {
      try {
        if (fallbackAudio) {
          fallbackAudio.pause();
          fallbackAudio = null;
        }
        var url = 'https://translate.google.com/translate_tts?ie=UTF-8&tl=pt-BR&client=tw-ob&q='
          + encodeURIComponent(text.toLowerCase());
        fallbackAudio = new Audio(url);
        fallbackAudio.play().catch(function () {});
      } catch (e) {}
    }, 250);
  }

  // ── Sound effect (ascending chime) ──
  function playChime(index, total) {
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const baseFreq = 523.25; // C5
      const freq = baseFreq * Math.pow(2, (index * 2) / 12); // go up in whole tones

      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.connect(gain);
      gain.connect(ctx.destination);

      osc.type = 'sine';
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(0.18, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.25);

      osc.start(ctx.currentTime);
      osc.stop(ctx.currentTime + 0.25);

      // Clean up
      osc.onended = function () { ctx.close(); };
    } catch (e) {
      // Audio not supported, no problem
    }
  }

  // ── Word completion animation ──
  function animateWordCompletion() {
    const text = pages[currentPage] || '';
    // Find the last word (before trailing space/newline)
    const trimmed = text.replace(/[\s]+$/, '');
    const lastBreak = Math.max(trimmed.lastIndexOf(' '), trimmed.lastIndexOf('\n'));
    const wordStart = lastBreak + 1;
    const wordLen = trimmed.length - wordStart;

    if (wordLen === 0) return;

    // Get all letter spans
    const letters = textDisplay.querySelectorAll('.letter');
    let letterSpans = [];
    for (let i = letters.length - wordLen; i < letters.length; i++) {
      if (letters[i]) letterSpans.push(letters[i]);
    }

    letterSpans.forEach(function (span, i) {
      setTimeout(function () {
        span.classList.add('blink');
        playChime(i, letterSpans.length);
        span.addEventListener('animationend', function () {
          span.classList.remove('blink');
        }, { once: true });
      }, i * 120);
    });
  }

  // ── Get current word being typed ──
  function getCurrentWord() {
    var text = pages[currentPage] || '';
    if (!text) return '';
    // Find last space or newline
    var lastBreak = Math.max(text.lastIndexOf(' '), text.lastIndexOf('\n'));
    return text.substring(lastBreak + 1);
  }

  // ── Typing logic ──
  function handleChar(ch) {
    const upper = ch.toUpperCase();
    pages[currentPage] = (pages[currentPage] || '') + upper;
    saveState();
    render();
    // Speak only the current word being typed
    var word = getCurrentWord();
    if (word) speak(word);
  }

  function handleSpace() {
    const text = pages[currentPage] || '';
    // Don't add space if empty or already ends with whitespace
    if (!text || text.endsWith(' ') || text.endsWith('\n')) return;

    // Speak the completed word
    var word = getCurrentWord();
    if (word) speak(word);

    // Trigger animation on the just-completed word before adding space
    animateWordCompletion();

    pages[currentPage] = text + ' ';
    saveState();
    render();
    // Re-trigger animation after render (since render rebuilds DOM)
    animateWordCompletion();
  }

  function handleBackspace() {
    const text = pages[currentPage] || '';
    if (text.length === 0) return;
    pages[currentPage] = text.slice(0, -1);
    saveState();
    render();
    var word = getCurrentWord();
    if (word) speak(word);
  }

  function handleEnter() {
    const text = pages[currentPage] || '';
    // Speak last word if any
    var word = getCurrentWord();
    if (word) speak(word);

    // Animate last word if there's text
    if (text.replace(/\s/g, '')) {
      animateWordCompletion();
    }

    // Add newline to current page
    pages[currentPage] = (pages[currentPage] || '') + '\n';
    saveState();
    render();
  }

  // ── Keyboard handling ──
  // All input goes through the hidden input element so that dead key
  // composition (ã, é, ç, ô, etc.) works natively via the browser's IME.
  var composing = false;

  hiddenInput.addEventListener('compositionstart', function () {
    composing = true;
  });

  hiddenInput.addEventListener('compositionend', function (e) {
    composing = false;
    // Process the composed result
    var val = hiddenInput.value;
    hiddenInput.value = '';
    if (val) {
      for (var i = 0; i < val.length; i++) {
        handleChar(val[i]);
      }
    }
  });

  hiddenInput.addEventListener('keydown', function (e) {
    if (composing) return;
    if (e.ctrlKey || e.metaKey || e.altKey) return;

    if (e.key === 'Backspace') {
      e.preventDefault();
      handleBackspace();
    } else if (e.key === 'Enter') {
      e.preventDefault();
      handleEnter();
    } else if (e.key === ' ') {
      e.preventDefault();
      handleSpace();
    }
    // Other keys: let them through to trigger input event (or start composition)
  });

  hiddenInput.addEventListener('input', function (e) {
    // Skip if we're in the middle of a dead key composition
    if (composing) return;

    var val = hiddenInput.value;
    hiddenInput.value = '';
    if (!val) return;

    for (var i = 0; i < val.length; i++) {
      var ch = val[i];
      if (ch === '\n') {
        handleEnter();
      } else if (ch === ' ') {
        handleSpace();
      } else {
        handleChar(ch);
      }
    }
  });

  // Keep input focused so all keystrokes go to it
  function focusInput() {
    hiddenInput.focus({ preventScroll: true });
  }

  // Redirect any stray keystrokes to the hidden input
  document.addEventListener('keydown', function (e) {
    if (document.activeElement !== hiddenInput) {
      focusInput();
    }
  });

  writingArea.addEventListener('click', focusInput);
  writingArea.addEventListener('touchend', function (e) {
    e.preventDefault();
    focusInput();
  });

  // ── Navigation ──
  btnPrev.addEventListener('click', function (e) {
    e.stopPropagation();
    if (currentPage > 0) {
      currentPage--;
      saveState();
      render();
    }
    focusInput();
  });

  btnNext.addEventListener('click', function (e) {
    e.stopPropagation();
    if (currentPage < pages.length - 1) {
      currentPage++;
      saveState();
      render();
    }
    focusInput();
  });

  btnNewPage.addEventListener('click', function (e) {
    e.stopPropagation();
    pages.push('');
    currentPage = pages.length - 1;
    saveState();
    render();
    focusInput();
  });

  // ── Init ──
  loadState();
  buildColorBar();
  render();

  // Auto-focus after a moment (helps on mobile)
  setTimeout(focusInput, 300);
})();
</script>
</body>
</html>
