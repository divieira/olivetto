<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Olivetto</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@700&display=swap" rel="stylesheet">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  html, body {
    height: 100%;
    overflow: hidden;
    font-family: 'Nunito', sans-serif;
    background: #fff;
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
    -webkit-user-select: none;
  }

  #app {
    display: flex;
    flex-direction: column;
    height: 100dvh;
    height: 100vh;
  }

  /* ── Color bar ── */
  #color-bar {
    display: flex;
    justify-content: center;
    gap: 12px;
    padding: 14px 10px 8px;
    flex-shrink: 0;
  }

  .color-dot {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    border: 3px solid transparent;
    cursor: pointer;
    transition: transform 0.15s, border-color 0.15s;
  }

  .color-dot:hover { transform: scale(1.15); }
  .color-dot.selected { border-color: #ccc; transform: scale(1.2); }

  /* ── Main writing area ── */
  #writing-area {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
    cursor: text;
    position: relative;
  }

  #text-display {
    font-size: min(18vw, 120px);
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    text-align: center;
    word-break: break-all;
    line-height: 1.2;
    color: #000;
  }

  #text-display .letter {
    display: inline-block;
    transition: opacity 0.1s;
  }

  #text-display .letter.blink {
    animation: letterBlink 0.35s ease-in-out;
  }

  @keyframes letterBlink {
    0%   { opacity: 1; transform: scale(1); }
    30%  { opacity: 0.2; transform: scale(1.15); }
    60%  { opacity: 1; transform: scale(1.05); }
    100% { opacity: 1; transform: scale(1); }
  }

  /* Blinking cursor */
  #cursor {
    display: inline-block;
    width: 3px;
    height: 0.9em;
    background: currentColor;
    margin-left: 2px;
    vertical-align: baseline;
    animation: cursorBlink 1s step-end infinite;
  }

  @keyframes cursorBlink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0; }
  }

  /* ── Hidden input for mobile keyboard ── */
  #hidden-input {
    position: absolute;
    left: -9999px;
    top: 0;
    opacity: 0;
    width: 1px;
    height: 1px;
  }

  /* ── Navigation ── */
  #nav-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 20px 16px;
    flex-shrink: 0;
  }

  .nav-btn {
    font-size: 32px;
    background: none;
    border: none;
    cursor: pointer;
    color: #bbb;
    padding: 8px 16px;
    border-radius: 12px;
    transition: color 0.15s, background 0.15s;
    font-family: 'Nunito', sans-serif;
    line-height: 1;
  }

  .nav-btn:hover { color: #888; background: #f0f0f0; }
  .nav-btn:disabled { opacity: 0.25; cursor: default; }
  .nav-btn:disabled:hover { background: none; color: #bbb; }

  #page-indicator {
    font-size: 14px;
    color: #ccc;
    font-weight: 700;
  }
</style>
</head>
<body>

<div id="app">
  <div id="color-bar"></div>

  <div id="writing-area">
    <div id="text-display"><span id="cursor"></span></div>
    <input id="hidden-input" type="text" autocapitalize="characters" autocomplete="off" autocorrect="off" spellcheck="false">
  </div>

  <div id="nav-bar">
    <button class="nav-btn" id="btn-prev" aria-label="Previous page">&#9664;</button>
    <span id="page-indicator"></span>
    <button class="nav-btn" id="btn-next" aria-label="Next page">&#9654;</button>
  </div>
</div>

<script>
(function () {
  // ── Config ──
  const COLORS = [
    { name: 'red',    hex: '#E53935' },
    { name: 'green',  hex: '#43A047' },
    { name: 'blue',   hex: '#1E88E5' },
    { name: 'yellow', hex: '#FDD835' },
    { name: 'orange', hex: '#FB8C00' },
    { name: 'pink',   hex: '#EC407A' },
    { name: 'purple', hex: '#8E24AA' },
    { name: 'black',  hex: '#222222' },
  ];

  const ALLOWED = /^[A-ZÀÁÂÃÇÉÊÍÓÔÕÚa-zàáâãçéêíóôõú]$/;
  const STORAGE_KEY = 'olivetto';

  // ── State ──
  let pages, currentPage, currentColor;

  function loadState() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (raw) {
        const s = JSON.parse(raw);
        pages = s.pages && s.pages.length ? s.pages : [''];
        currentPage = typeof s.currentPage === 'number' ? Math.min(s.currentPage, pages.length - 1) : 0;
        currentColor = s.color || COLORS[7].hex;
      } else {
        pages = [''];
        currentPage = 0;
        currentColor = COLORS[7].hex;
      }
    } catch {
      pages = [''];
      currentPage = 0;
      currentColor = COLORS[7].hex;
    }
  }

  function saveState() {
    localStorage.setItem(STORAGE_KEY, JSON.stringify({
      pages: pages,
      currentPage: currentPage,
      color: currentColor,
    }));
  }

  // ── DOM refs ──
  const textDisplay = document.getElementById('text-display');
  const cursor = document.getElementById('cursor');
  const hiddenInput = document.getElementById('hidden-input');
  const colorBar = document.getElementById('color-bar');
  const btnPrev = document.getElementById('btn-prev');
  const btnNext = document.getElementById('btn-next');
  const pageIndicator = document.getElementById('page-indicator');
  const writingArea = document.getElementById('writing-area');

  // ── Render ──
  function render() {
    const text = pages[currentPage] || '';

    // Build letter spans
    let html = '';
    for (let i = 0; i < text.length; i++) {
      const ch = text[i];
      if (ch === ' ') {
        html += ' ';
      } else {
        html += '<span class="letter">' + ch + '</span>';
      }
    }

    textDisplay.innerHTML = html;
    textDisplay.appendChild(cursor);
    textDisplay.style.color = currentColor;

    // Nav
    btnPrev.disabled = currentPage === 0;
    pageIndicator.textContent = (currentPage + 1) + ' / ' + pages.length;
  }

  // ── Color bar ──
  function buildColorBar() {
    COLORS.forEach(function (c) {
      const dot = document.createElement('div');
      dot.className = 'color-dot';
      dot.style.background = c.hex;
      if (c.hex === currentColor) dot.classList.add('selected');
      dot.addEventListener('click', function (e) {
        e.stopPropagation();
        currentColor = c.hex;
        document.querySelectorAll('.color-dot').forEach(function (d) { d.classList.remove('selected'); });
        dot.classList.add('selected');
        saveState();
        render();
        focusInput();
      });
      colorBar.appendChild(dot);
    });
  }

  // ── Speech ──
  function speak(text) {
    if (!text || !window.speechSynthesis) return;
    window.speechSynthesis.cancel();
    const u = new SpeechSynthesisUtterance(text);
    u.lang = 'pt-BR';
    u.rate = 0.9;
    window.speechSynthesis.speak(u);
  }

  // ── Sound effect (ascending chime) ──
  function playChime(index, total) {
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const baseFreq = 523.25; // C5
      const freq = baseFreq * Math.pow(2, (index * 2) / 12); // go up in whole tones

      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.connect(gain);
      gain.connect(ctx.destination);

      osc.type = 'sine';
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(0.18, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.25);

      osc.start(ctx.currentTime);
      osc.stop(ctx.currentTime + 0.25);

      // Clean up
      osc.onended = function () { ctx.close(); };
    } catch (e) {
      // Audio not supported, no problem
    }
  }

  // ── Word completion animation ──
  function animateWordCompletion() {
    const text = pages[currentPage] || '';
    // Find the last word (before trailing space)
    const trimmed = text.trimEnd();
    const lastSpace = trimmed.lastIndexOf(' ');
    const wordStart = lastSpace + 1;
    const wordLen = trimmed.length - wordStart;

    if (wordLen === 0) return;

    // Get all letter spans
    const letters = textDisplay.querySelectorAll('.letter');
    // The word letters are the last `wordLen` letter-spans (not counting spaces)
    let letterSpans = [];
    for (let i = letters.length - wordLen; i < letters.length; i++) {
      if (letters[i]) letterSpans.push(letters[i]);
    }

    letterSpans.forEach(function (span, i) {
      setTimeout(function () {
        span.classList.add('blink');
        playChime(i, letterSpans.length);
        span.addEventListener('animationend', function () {
          span.classList.remove('blink');
        }, { once: true });
      }, i * 120);
    });
  }

  // ── Typing logic ──
  function handleChar(ch) {
    const upper = ch.toUpperCase();
    pages[currentPage] = (pages[currentPage] || '') + upper;
    saveState();
    render();
    speak(pages[currentPage].trim());
  }

  function handleSpace() {
    const text = pages[currentPage] || '';
    // Don't add space if empty or already ends with space
    if (!text || text.endsWith(' ')) return;

    // Trigger animation on the just-completed word before adding space
    animateWordCompletion();

    pages[currentPage] = text + ' ';
    saveState();
    render();
    // Re-trigger animation after render (since render rebuilds DOM)
    animateWordCompletion();
  }

  function handleBackspace() {
    const text = pages[currentPage] || '';
    if (text.length === 0) return;
    pages[currentPage] = text.slice(0, -1);
    saveState();
    render();
    const remaining = pages[currentPage].trim();
    if (remaining) speak(remaining);
  }

  function handleEnter() {
    const text = pages[currentPage] || '';
    // Animate last word if there's text
    if (text.trim()) {
      animateWordCompletion();
    }
    // Create new page after a short delay so animation plays
    setTimeout(function () {
      // Only add new page if current has content, or we're at the last page
      if (currentPage === pages.length - 1) {
        pages.push('');
      }
      currentPage = currentPage + 1;
      // If next page doesn't exist yet, make it
      if (currentPage >= pages.length) {
        pages.push('');
      }
      saveState();
      render();
    }, text.trim() ? 400 : 0);
  }

  // ── Keyboard handling ──
  // Desktop: listen on document
  document.addEventListener('keydown', function (e) {
    // Ignore if modifier keys (except shift)
    if (e.ctrlKey || e.metaKey || e.altKey) return;

    if (e.key === 'Backspace') {
      e.preventDefault();
      handleBackspace();
    } else if (e.key === 'Enter') {
      e.preventDefault();
      handleEnter();
    } else if (e.key === ' ') {
      e.preventDefault();
      handleSpace();
    } else if (ALLOWED.test(e.key)) {
      e.preventDefault();
      handleChar(e.key);
    }
  });

  // Mobile: use hidden input for soft keyboard
  hiddenInput.addEventListener('input', function (e) {
    const val = hiddenInput.value;
    hiddenInput.value = '';
    if (!val) return;

    for (let i = 0; i < val.length; i++) {
      const ch = val[i];
      if (ch === ' ') {
        handleSpace();
      } else if (ALLOWED.test(ch)) {
        handleChar(ch);
      }
    }
  });

  // Keep input focused for mobile keyboard
  function focusInput() {
    hiddenInput.focus({ preventScroll: true });
  }

  writingArea.addEventListener('click', focusInput);
  writingArea.addEventListener('touchend', function (e) {
    e.preventDefault();
    focusInput();
  });

  // ── Navigation ──
  btnPrev.addEventListener('click', function (e) {
    e.stopPropagation();
    if (currentPage > 0) {
      currentPage--;
      saveState();
      render();
    }
    focusInput();
  });

  btnNext.addEventListener('click', function (e) {
    e.stopPropagation();
    if (currentPage < pages.length - 1) {
      currentPage++;
    } else {
      pages.push('');
      currentPage = pages.length - 1;
    }
    saveState();
    render();
    focusInput();
  });

  // ── Init ──
  loadState();
  buildColorBar();
  render();

  // Auto-focus after a moment (helps on mobile)
  setTimeout(focusInput, 300);
})();
</script>
</body>
</html>
